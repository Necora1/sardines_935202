#include <iostream>
#include "math.h"
#define elems 10

using namespace std;
// Lab 08
void test(int &x1, int *x2) {
    x1 = 10;

    *x2 = 312;

}  

void sortsimple(int *arrray, int size);
void mergearr(int array1[], int array2[], int size1, int size2, int array3[]);

int main() {
    // Упражнение 1: объяснить использование типов/переменных в коде (без ввода).
    
    // #define N 5 - объявляем именованную константу со значением 5

    // Typedef long int MyInt; - создаём своё имя для уже ранее известного типа данных(long int теперь будет MyInt)

    // Double g(int, int); - объявляем функцию(задаем её прототип). Определяем только её имя и типы параметров

    // Int a = 100; - создаём глобальную переменную a с типом данных int и задаём ей значение 100

    // Int _tmain(int argc, _TCHAR* argv[]) - создаём главную функцию _tmain с параметром argc - argument count(тип данных int, отвечает за количество прошедших переменных при запуске программы) и _TCHAR* argv[] (динамический массив данных Argument Vector, захватывает значения прошедших переменных, все значения argv[] сохранены как _TCHAR* поскольку в C++Builder _TCHAR* облегчает написание исходного кода, который может быть использован со строками.

    // Float a; - объявляет переменную a с типом данных float

    // Int d = 123, t = 456; - объявляет 2 переменные d и t с соответствующими значениями 123 и 456 с типом данных int

    // Double n,m; - объявляет 2 переменные n и m с типом данных Double

    // MyInt l = 0; - объявляет переменную l со значением 0 и типом данных MyInt(Long Int)

    // a = 3.14; - задаёт значение переменной a

    // For (int a = 0; a < N; a++) l += a; - создаём цикл в котором объявляем переменную a с типом данных int и задаём ей значение 0. Условие a < N, что означает, цикл будет работать до тех пор, пока a не превысит значение именной константы N (5). a++ - увеличивает переменную a на 1 при каждом проходе цикла. В самом цикле переменная l увеличивается на значение a

    // n  = l * N + a; - задаём значение переменной n, в которой l(0, MyInt) умножается на N(5) и прибавляется a(3.14)

    //     m = g(d, t); - задаём переменную m, в которой используется функция g теперь со значениями d = 123 и t = 456

    // Double g(int d, int t)

    // {
	// return a / d + t;
    // } - определяем функцию g с параметрами d и t, оба типа данных которых int. Функция возвращает a(100, int) / d (переданное значение, int) + t(переданное значение, int)

    // N = 10 * 5 + 3.14 = 53.14
    // M = 100 / 123 + 456 = 456

    // Упражнение 2: найти ошибки в коде (без ввода).
    // Ошибки:

    // 1. Int *x, *y, *z, d; - работаем с указателями, но на строчке cin >> *x >> *y >> *z; у нас вводятся значения в никуда, поскольку память ещё не была выделена, нам нужно это выделить, для этого прописываем x = new int  y = new int  z = new int перед функцией main() 

    // 2. If (x > y) - мы сравниваем адреса, но по смыслу задачи нам нужно сравнивать числа, соответсвенно эта строчка и все подобные ей должны выглядеть как: if (*x > *y)

    // 3. d = *x; x = y; *y = d; - x = y не допускается, так как мы присваиваем адрес y адресу x, нам нужно присваивать значения, соотвественно: *x = *y

    // 4. Строчка cout << “ x=" << x << “ y=" << y << " z=" << z << " difference = " << z - x << endl; должна выглядеть как cout << “ x=" << *x << “ y=" << *y << " z=" << *z << " difference = " << *z - *x << endl; из-за того, что x y z указатели

    // 5. В конце память нужно освободить для 3 указателей с помощью: delete x, y, z;

    // Какую задачу решает данная программа: Данная программа принимает 3 числа в переменных-указателях *x *y *z и далее меняет местами их значения по следующим условиям: (x > y), (x > z), (y > z), в случае успешного выполнения условий меняются местами: *x = *y, *z = *x, *y = *z соотвественно. В конце программа выводит уже 3 значения x y и z после преобразований и считает разницу между z и x.    

    // 2)    Ссылки и указатели:

    // Ссылки только ссылаются на уже ранее заданную переменную, значения передаваемые через ссылки должны быть того же типа что и переменная, на которую ссылка указывает. Другими словами, ссылка это альтернативное название уже заданной переменной, для присваивания переменной ссылки мы используем &, вызывать ссылку можно как и обычную переменную.

    // Указатели являются переменными, у которых значение - адрес области памяти, выделенной для переменной или значения. Указатель объявляется как int *x; где int - тип данных, *x - сам указатель, * обязятелен, так как тем самым мы обозначаем, что мы объявили указатель. Для указателя нужно либо выделять память с помощью x = new int; и не забывать в конце освобождать её с помощью delete x; , либо мы можем получать адрес некой переменной с помощью & и присваивать её указателю. Если в любых ситуациях (кроме объявления указателя) нам нужно получить значение указателя, мы проводим операцию разыменования с помощью *. Важно заметить, что при арифм. Операциях с указателями ( по типу x++) значения будут увеличиваться не на 1, а на кол-во байтов в зависимости от типа данных указателя x.
    
    // указатель 
    int *x;

    x = new int; 
    *x = 31;
    cout << *x << endl;
    cout << "Введите новое значение x -> ";
    cin >> *x;
    cout << *x << endl;
    cout << "----------------------------" << endl;
    // ссылка
    int y = 12;
    int &refy = y;
    cout << refy << endl;
    cout << "Введите новое значение y -> ";
    cin >> refy;
    cout << refy << endl;
    test(refy, x);
    cout << refy << " " << *x;

    // Упражнение 3: заполнить массивы (10 элементов) разными способами.
    
    //Статический массив, индексная адресация 
    int staar[elems];
    int temp;
    cout << "Введите элементы массива" << endl;
    for (int i = 0; i < elems; i++) {
        
        cin >> temp;
        staar[i] = pow(temp,2);
    }

    cout << "Все элементы статического индексного массива в квадрате: ";

    for (int i = 0; i < elems; i++) {
        
        cout << staar[i] << " ";
    }

    cout << endl << "---------------------------------------------------------" << endl;
    //Статический массив, адресация с помощью указателя (косвенная адресация)
    int staarpo[elems];
    int *po;
    po = staarpo;
    cout << "Введите элементы массива" << endl;
    for (int i = 0; i < elems; i++) {
        
        cin >> temp;
        *po = pow(temp,2);
        po++;
    }
    cout << "Все элементы статического индексного массива в квадрате(косвенная адресация): ";
    po = staarpo;

    for (int i = 0; i < elems; i++) {
        
        cout << *po << " ";
        po++;
    }
    cout << endl << "---------------------------------------------------------" << endl;
    //Динамический массив, индексная адресация
    int *dynaar;
    dynaar = new int [elems];
    cout << "Введите элементы массива" << endl;
    for (int i = 0; i < elems; i++) {
        
        cin >> temp;
        dynaar[i] = pow(temp,2);
    }

    cout << "Все элементы динамического индексного массива в квадрате: ";

    for (int i = 0; i < elems; i++) {
        
        cout << dynaar[i] << " ";
    }
    delete [] dynaar;
    cout << endl << "---------------------------------------------------------" << endl;
    //Динамический массив, адресация  с помощью указателя (косвенная адресация)
    int *dynaarpo;
    dynaarpo = new int [elems];
    int *ponew = dynaarpo;
    cout << "Введите элементы массива" << endl;
    for (int i = 0; i < elems; i++) {
        
        cin >> temp;
        *dynaarpo = pow(temp,2);
        ponew++;
    }
    ponew = dynaarpo;
    cout << "Все элементы динамического индексного массива в квадрате(косвенная адресация): ";

    for (int i = 0; i < elems; i++) {
        
        cout << dynaarpo[i] << " ";
        ponew++;
    }
    delete [] dynaarpo;
    // Упражнение 4: линейный самоадресуемый список из 10 элементов.
    // TODO: сформируйте список и выведите элементы по порядку.
    int *dynaarpoi, *dynaarind, *dynamerarr, *po1;
    dynaarpoi = new int [15];
    dynaarind = new int [15];
    po1 = dynaarpoi;
    string tempp;
    int c = 0;
    int maxSize1 = 0;
    int maxSize2 = 0;
    cout << "Введите числа первого массива через Enter" << endl;
    cout << "После последнего написанного числа введите end для формирования массива" << endl;
   
    for (int i = 0;; i++) {
        
        if (i < 15) {
            cin >> tempp;

            if (tempp == "end") {

            maxSize1 = c;
            c = 0;
            cout << "Первый массив был сформирован" << endl;
            break;
            

        } else {
            *po1 = stoi(tempp);
            po1++;
            c++;
            cout << "Текущее кол-во элементов в массиве: " << c << ", введите следующее число, либо слово end: ";
            tempp = "";

        }

        } else {
            cout << "Было достигнуто максимальное количество элементов в массиве";
            exit(1);
            
        }

    }
    for (int i =0;i < maxSize1;i++) {

            cout << dynaarpoi[i] << " ";
    }
    cout << endl;

    sortsimple(dynaarpoi, maxSize1);
    cout << "Отсортированный массив" << endl;

    for (int i =0;i < maxSize1;i++) {

            cout << dynaarpoi[i] << " ";
    }

    cout << endl << "-----------------------------------------------------------------" << endl;
    cout << "Введите числа второго массива через Enter." << endl;
    cout << "После последнего написанного числа введите end для формирования массива" << endl;
   
    int index = 0;
    c = 0;

    for (int i = 0;; i++) {
        
        if (i < 15) {
            cin >> tempp;

            if (tempp == "end") {

            maxSize2 = c;
            c = 0;
            cout << "Второй массив был сформирован" << endl;   
            break;
            

        } else {

            dynaarind[index] = stoi(tempp);
            index++;
            c++;
            cout << "Текущее кол-во элементов в массиве: " << c << ", введите следующее число, либо слово end: ";
            tempp = "";

        }

        } else {
            cout << "Было достигнуто максимальное количество элементов в массиве";
            exit(1);
            
        }

    }
    for (int i =0;i < maxSize2;i++) {

            cout << dynaarind[i] << " ";
    }

    cout << endl;
    sortsimple(dynaarind, maxSize2);
    cout << "Отсортированный массив" << endl;
    
    for (int i =0;i < maxSize2;i++) {

            cout << dynaarind[i] << " ";
    }

    dynamerarr = new int [maxSize1 + maxSize2];
    cout << endl << "-----------------------------------------------------------------" << endl;
    cout << "Остортированный, слитый из двух массив: " << endl;
    mergearr(dynaarpoi, dynaarind, maxSize1, maxSize2, dynamerarr);

    for (int i = 0; i < maxSize1+maxSize2; i++)
        cout << dynamerarr[i] << " ";
}

void sortsimple(int *array, int size) {

    int i, j, temp;
    for (i = 0;i < size;i++) {

        for (j = i + 1;j < size;j++) {

            if (*(array + j) < *(array +i)) {

                    temp = *(array +i);
                    *(array + i) = *(array + j);
                    *(array + j) = temp;
            }
        }
    }
}

void mergearr(int array1[], int array2[], int size1, int size2, int array3[]) {
    int i = 0;
    int *ptr = array2;
    int *ptrMer = array3;


    while (size1 > 0 && size2 > 0) {

        if (array1[i] < *ptr) {
            *ptrMer = array1[i];
            i++;
            size1--;
            ptrMer++;
            
        } else {
            *ptrMer = *ptr;
            ptr++;
            size2--;
            ptrMer++;
            
        }
    }

    while (size1 > 0) {
        *ptrMer = array1[i];
        i++;
        ptrMer++;
        size1--;
        
    }

    while (size2 > 0) {
        *ptrMer = *ptr;
        ptr++;
        ptrMer++;
        size2--;
    }

}
